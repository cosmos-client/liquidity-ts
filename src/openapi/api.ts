/* tslint:disable */
/* eslint-disable */
/**
 * Cosmos SDK Liquidity Module - REST and gRPC Gateway docs
 * A REST interface for state queries, transactions
 *
 * The version of the OpenAPI document: 2.3.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageRequest
 */
export interface CosmosBaseQueryV1beta1PageRequest {
    /**
     * key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    key?: string;
    /**
     * offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    offset?: string;
    /**
     * limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    limit?: string;
    /**
     * count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @type {boolean}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    count_total?: boolean;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageResponse
 */
export interface CosmosBaseQueryV1beta1PageResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageResponse
     */
    next_key?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageResponse
     */
    total?: string;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface CosmosBaseV1beta1Coin
 */
export interface CosmosBaseV1beta1Coin {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1Coin
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1Coin
     */
    amount?: string;
}
/**
 * 
 * @export
 * @interface GoogleProtobufAny
 */
export interface GoogleProtobufAny {
    /**
     * 
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    type_url?: string;
    /**
     * 
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface GrpcGatewayRuntimeError
 */
export interface GrpcGatewayRuntimeError {
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    message?: string;
    /**
     * 
     * @type {Array<InlineResponseDefaultDetails>}
     * @memberof GrpcGatewayRuntimeError
     */
    details?: Array<InlineResponseDefaultDetails>;
}
/**
 * the response type for the QueryParamsResponse RPC method. This includes current parameter of the liquidity module.
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {InlineResponse200Params}
     * @memberof InlineResponse200
     */
    params?: InlineResponse200Params;
}
/**
 * the response type for the QueryLiquidityPoolsResponse RPC method. This includes a list of all existing liquidity pools and paging results that contain next_key and total count.
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Array<InlineResponse2001Pools>}
     * @memberof InlineResponse2001
     */
    pools?: Array<InlineResponse2001Pools>;
    /**
     * 
     * @type {InlineResponse2001Pagination}
     * @memberof InlineResponse2001
     */
    pagination?: InlineResponse2001Pagination;
}
/**
 * pagination defines the pagination in the response. not working on this version.
 * @export
 * @interface InlineResponse2001Pagination
 */
export interface InlineResponse2001Pagination {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Pagination
     */
    next_key?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Pagination
     */
    total?: string;
}
/**
 * Pool defines the liquidity pool that contains pool information.
 * @export
 * @interface InlineResponse2001Pools
 */
export interface InlineResponse2001Pools {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Pools
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001Pools
     */
    type_id?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse2001Pools
     */
    reserve_coin_denoms?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Pools
     */
    reserve_account_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Pools
     */
    pool_coin_denom?: string;
}
/**
 * the response type for the QueryLiquidityPoolResponse RPC method. Returns the liquidity pool that corresponds to the requested pool_id.
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {InlineResponse2001Pools}
     * @memberof InlineResponse2002
     */
    pool?: InlineResponse2001Pools;
}
/**
 * the response type for the QueryLiquidityPoolBatchResponse RPC method. Returns the liquidity pool batch that corresponds to the requested pool_id.
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {InlineResponse2003Batch}
     * @memberof InlineResponse2003
     */
    batch?: InlineResponse2003Batch;
}
/**
 * PoolBatch defines the batch or batches of a given liquidity pool that contains indexes of deposit, withdraw, and swap messages.  Index param increments by 1 if the pool id is same.
 * @export
 * @interface InlineResponse2003Batch
 */
export interface InlineResponse2003Batch {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Batch
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Batch
     */
    index?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Batch
     */
    begin_height?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Batch
     */
    deposit_msg_index?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Batch
     */
    withdraw_msg_index?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Batch
     */
    swap_msg_index?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2003Batch
     */
    executed?: boolean;
}
/**
 * the response type for the QueryPoolBatchDeposit RPC method. This includes a list of all currently existing deposit messages of the batch and paging results that contain next_key and total count.
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {Array<InlineResponse2004Deposits>}
     * @memberof InlineResponse2004
     */
    deposits?: Array<InlineResponse2004Deposits>;
    /**
     * 
     * @type {InlineResponse2001Pagination}
     * @memberof InlineResponse2004
     */
    pagination?: InlineResponse2001Pagination;
}
/**
 * DepositMsgState defines the state of deposit message that contains state information as it is processed in the next batch or batches.
 * @export
 * @interface InlineResponse2004Deposits
 */
export interface InlineResponse2004Deposits {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Deposits
     */
    msg_height?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Deposits
     */
    msg_index?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2004Deposits
     */
    executed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2004Deposits
     */
    succeeded?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2004Deposits
     */
    to_be_deleted?: boolean;
    /**
     * 
     * @type {MsgDepositWithinBatch}
     * @memberof InlineResponse2004Deposits
     */
    msg?: MsgDepositWithinBatch;
}
/**
 * the response type for the QueryPoolBatchDepositMsg RPC method. This includes a batch swap message of the batch.
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {InlineResponse2004Deposits}
     * @memberof InlineResponse2005
     */
    deposit?: InlineResponse2004Deposits;
}
/**
 * the response type for the QueryPoolBatchSwapMsgs RPC method. This includes list of all currently existing swap messages of the batch and paging results that contain next_key and total count.
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {Array<InlineResponse2006Swaps>}
     * @memberof InlineResponse2006
     */
    swaps?: Array<InlineResponse2006Swaps>;
    /**
     * 
     * @type {InlineResponse2001Pagination}
     * @memberof InlineResponse2006
     */
    pagination?: InlineResponse2001Pagination;
}
/**
 * SwapMsgState defines the state of the swap message that contains state information as the message is processed in the next batch or batches.
 * @export
 * @interface InlineResponse2006Swaps
 */
export interface InlineResponse2006Swaps {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Swaps
     */
    msg_height?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Swaps
     */
    msg_index?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2006Swaps
     */
    executed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2006Swaps
     */
    succeeded?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2006Swaps
     */
    to_be_deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Swaps
     */
    order_expiry_height?: string;
    /**
     * 
     * @type {OfferCoinExchangedUntilNow}
     * @memberof InlineResponse2006Swaps
     */
    exchanged_offer_coin?: OfferCoinExchangedUntilNow;
    /**
     * 
     * @type {OfferCoinCurrentlyRemainingToBeExchanged}
     * @memberof InlineResponse2006Swaps
     */
    remaining_offer_coin?: OfferCoinCurrentlyRemainingToBeExchanged;
    /**
     * 
     * @type {ReserveFeeForPaysFeeInHalfOfferCoin}
     * @memberof InlineResponse2006Swaps
     */
    reserved_offer_coin_fee?: ReserveFeeForPaysFeeInHalfOfferCoin;
    /**
     * 
     * @type {MsgSwapWithinBatch}
     * @memberof InlineResponse2006Swaps
     */
    msg?: MsgSwapWithinBatch;
}
/**
 * the response type for the QueryPoolBatchSwapMsg RPC method. This includes a batch swap message of the batch.
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {InlineResponse2006Swaps}
     * @memberof InlineResponse2007
     */
    swap?: InlineResponse2006Swaps;
}
/**
 * the response type for the QueryPoolBatchWithdraw RPC method. This includes a list of all currently existing withdraw messages of the batch and paging results that contain next_key and total count.
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {Array<InlineResponse2008Withdraws>}
     * @memberof InlineResponse2008
     */
    withdraws?: Array<InlineResponse2008Withdraws>;
    /**
     * 
     * @type {InlineResponse2008Pagination}
     * @memberof InlineResponse2008
     */
    pagination?: InlineResponse2008Pagination;
}
/**
 * pagination defines the pagination in the response. Not supported on this version.
 * @export
 * @interface InlineResponse2008Pagination
 */
export interface InlineResponse2008Pagination {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008Pagination
     */
    next_key?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008Pagination
     */
    total?: string;
}
/**
 * WithdrawMsgState defines the state of the withdraw message that contains state information as the message is processed in the next batch or batches.
 * @export
 * @interface InlineResponse2008Withdraws
 */
export interface InlineResponse2008Withdraws {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008Withdraws
     */
    msg_height?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008Withdraws
     */
    msg_index?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2008Withdraws
     */
    executed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2008Withdraws
     */
    succeeded?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2008Withdraws
     */
    to_be_deleted?: boolean;
    /**
     * 
     * @type {MsgWithdrawWithinBatch}
     * @memberof InlineResponse2008Withdraws
     */
    msg?: MsgWithdrawWithinBatch;
}
/**
 * the response type for the QueryPoolBatchWithdrawMsg RPC method. This includes a batch swap message of the batch.
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {InlineResponse2008Withdraws}
     * @memberof InlineResponse2009
     */
    withdraw?: InlineResponse2008Withdraws;
}
/**
 * params holds all the parameters of this module.
 * @export
 * @interface InlineResponse200Params
 */
export interface InlineResponse200Params {
    /**
     * 
     * @type {Array<InlineResponse200ParamsPoolTypes>}
     * @memberof InlineResponse200Params
     */
    pool_types?: Array<InlineResponse200ParamsPoolTypes>;
    /**
     * Minimum number of coins to be deposited to the liquidity pool on pool creation.
     * @type {string}
     * @memberof InlineResponse200Params
     */
    min_init_deposit_amount?: string;
    /**
     * Initial mint amount of pool coins upon pool creation.
     * @type {string}
     * @memberof InlineResponse200Params
     */
    init_pool_coin_mint_amount?: string;
    /**
     * Limit the size of each liquidity pool to minimize risk. In development, set to 0 for no limit. In production, set a limit.
     * @type {string}
     * @memberof InlineResponse200Params
     */
    max_reserve_coin_amount?: string;
    /**
     * Fee paid to create a Liquidity Pool. Set a fee to prevent spamming.
     * @type {Array<InlineResponse200ParamsPoolCreationFee>}
     * @memberof InlineResponse200Params
     */
    pool_creation_fee?: Array<InlineResponse200ParamsPoolCreationFee>;
    /**
     * Swap fee rate for every executed swap.
     * @type {string}
     * @memberof InlineResponse200Params
     */
    swap_fee_rate?: string;
    /**
     * Reserve coin withdrawal with less proportion by withdrawFeeRate.
     * @type {string}
     * @memberof InlineResponse200Params
     */
    withdraw_fee_rate?: string;
    /**
     * Maximum ratio of reserve coins that can be ordered at a swap order.
     * @type {string}
     * @memberof InlineResponse200Params
     */
    max_order_amount_ratio?: string;
    /**
     * The smallest unit batch height for every liquidity pool.
     * @type {number}
     * @memberof InlineResponse200Params
     */
    unit_batch_height?: number;
    /**
     * Circuit breaker enables or disables transaction messages in liquidity module.
     * @type {boolean}
     * @memberof InlineResponse200Params
     */
    circuit_breaker_enabled?: boolean;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface InlineResponse200ParamsPoolCreationFee
 */
export interface InlineResponse200ParamsPoolCreationFee {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200ParamsPoolCreationFee
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200ParamsPoolCreationFee
     */
    amount?: string;
}
/**
 * Structure for the pool type to distinguish the characteristics of the reserve pools.
 * @export
 * @interface InlineResponse200ParamsPoolTypes
 */
export interface InlineResponse200ParamsPoolTypes {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200ParamsPoolTypes
     */
    id?: number;
    /**
     * name of the pool type.
     * @type {string}
     * @memberof InlineResponse200ParamsPoolTypes
     */
    name?: string;
    /**
     * minimum number of reserveCoins for LiquidityPoolType, only 2 reserve coins are supported.
     * @type {number}
     * @memberof InlineResponse200ParamsPoolTypes
     */
    min_reserve_coin_num?: number;
    /**
     * maximum number of reserveCoins for LiquidityPoolType, only 2 reserve coins are supported.
     * @type {number}
     * @memberof InlineResponse200ParamsPoolTypes
     */
    max_reserve_coin_num?: number;
    /**
     * description of the pool type.
     * @type {string}
     * @memberof InlineResponse200ParamsPoolTypes
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault
 */
export interface InlineResponseDefault {
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault
     */
    message?: string;
    /**
     * 
     * @type {Array<InlineResponseDefaultDetails>}
     * @memberof InlineResponseDefault
     */
    details?: Array<InlineResponseDefaultDetails>;
}
/**
 * 
 * @export
 * @interface InlineResponseDefaultDetails
 */
export interface InlineResponseDefaultDetails {
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefaultDetails
     */
    type_url?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefaultDetails
     */
    value?: string;
}
/**
 * `MsgDepositWithinBatch defines` an `sdk.Msg` type that supports submitting  a deposit request to the batch of the liquidity pool. Deposit is submitted to the batch of the Liquidity pool with the specified  `pool_id`, `deposit_coins` for reserve. This request is stacked in the batch of the liquidity pool, is not processed  immediately, and is processed in the `endblock` at the same time as other requests.  See: https://github.com/tendermint/liquidity/blob/develop/x/liquidity/spec/04_messages.md
 * @export
 * @interface MsgDepositWithinBatch
 */
export interface MsgDepositWithinBatch {
    /**
     * account address of the origin of this message
     * @type {string}
     * @memberof MsgDepositWithinBatch
     */
    depositor_address?: string;
    /**
     * 
     * @type {string}
     * @memberof MsgDepositWithinBatch
     */
    pool_id?: string;
    /**
     * 
     * @type {Array<InlineResponse200ParamsPoolCreationFee>}
     * @memberof MsgDepositWithinBatch
     */
    deposit_coins?: Array<InlineResponse200ParamsPoolCreationFee>;
}
/**
 * `MsgSwapWithinBatch` defines an sdk.Msg type that supports submitting a swap offer request to the batch of the liquidity pool. Submit swap offer to the liquidity pool batch with the specified the `pool_id`, `swap_type_id`, `demand_coin_denom` with the coin and the price you\'re offering and `offer_coin_fee` must be half of offer coin amount * current `params.swap_fee_rate` and ceil for reservation to pay fees. This request is stacked in the batch of the liquidity pool, is not processed  immediately, and is processed in the `endblock` at the same time as other requests. You must request the same fields as the pool. Only the default `swap_type_id` 1 is supported.  See: https://github.com/tendermint/liquidity/tree/develop/doc https://github.com/tendermint/liquidity/blob/develop/x/liquidity/spec/04_messages.md
 * @export
 * @interface MsgSwapWithinBatch
 */
export interface MsgSwapWithinBatch {
    /**
     * account address of the origin of this message
     * @type {string}
     * @memberof MsgSwapWithinBatch
     */
    swap_requester_address?: string;
    /**
     * id of swap type, must match the value in the pool. Only `swap_type_id` 1 is supported.
     * @type {string}
     * @memberof MsgSwapWithinBatch
     */
    pool_id?: string;
    /**
     * id of swap type. Must match the value in the pool.
     * @type {number}
     * @memberof MsgSwapWithinBatch
     */
    swap_type_id?: number;
    /**
     * 
     * @type {MsgSwapWithinBatchOfferCoin}
     * @memberof MsgSwapWithinBatch
     */
    offer_coin?: MsgSwapWithinBatchOfferCoin;
    /**
     * denom of demand coin to be exchanged on the swap request, must match the denom in the pool.
     * @type {string}
     * @memberof MsgSwapWithinBatch
     */
    demand_coin_denom?: string;
    /**
     * 
     * @type {MsgSwapWithinBatchOfferCoinFee}
     * @memberof MsgSwapWithinBatch
     */
    offer_coin_fee?: MsgSwapWithinBatchOfferCoinFee;
    /**
     * limit order price for the order, the price is the exchange ratio of X/Y where X is the amount of the first coin and Y is the amount  of the second coin when their denoms are sorted alphabetically.
     * @type {string}
     * @memberof MsgSwapWithinBatch
     */
    order_price?: string;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface MsgSwapWithinBatchOfferCoin
 */
export interface MsgSwapWithinBatchOfferCoin {
    /**
     * 
     * @type {string}
     * @memberof MsgSwapWithinBatchOfferCoin
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof MsgSwapWithinBatchOfferCoin
     */
    amount?: string;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface MsgSwapWithinBatchOfferCoinFee
 */
export interface MsgSwapWithinBatchOfferCoinFee {
    /**
     * 
     * @type {string}
     * @memberof MsgSwapWithinBatchOfferCoinFee
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof MsgSwapWithinBatchOfferCoinFee
     */
    amount?: string;
}
/**
 * `MsgWithdrawWithinBatch` defines an `sdk.Msg` type that supports submitting  a withdraw request to the batch of the liquidity pool. Withdraw is submitted to the batch from the Liquidity pool with the  specified `pool_id`, `pool_coin` of the pool. This request is stacked in the batch of the liquidity pool, is not processed  immediately, and is processed in the `endblock` at the same time as other requests.  See: https://github.com/tendermint/liquidity/blob/develop/x/liquidity/spec/04_messages.md
 * @export
 * @interface MsgWithdrawWithinBatch
 */
export interface MsgWithdrawWithinBatch {
    /**
     * account address of the origin of this message
     * @type {string}
     * @memberof MsgWithdrawWithinBatch
     */
    withdrawer_address?: string;
    /**
     * 
     * @type {string}
     * @memberof MsgWithdrawWithinBatch
     */
    pool_id?: string;
    /**
     * 
     * @type {MsgWithdrawWithinBatchPoolCoin}
     * @memberof MsgWithdrawWithinBatch
     */
    pool_coin?: MsgWithdrawWithinBatchPoolCoin;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface MsgWithdrawWithinBatchPoolCoin
 */
export interface MsgWithdrawWithinBatchPoolCoin {
    /**
     * 
     * @type {string}
     * @memberof MsgWithdrawWithinBatchPoolCoin
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof MsgWithdrawWithinBatchPoolCoin
     */
    amount?: string;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface OfferCoinCurrentlyRemainingToBeExchanged
 */
export interface OfferCoinCurrentlyRemainingToBeExchanged {
    /**
     * 
     * @type {string}
     * @memberof OfferCoinCurrentlyRemainingToBeExchanged
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferCoinCurrentlyRemainingToBeExchanged
     */
    amount?: string;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface OfferCoinExchangedUntilNow
 */
export interface OfferCoinExchangedUntilNow {
    /**
     * 
     * @type {string}
     * @memberof OfferCoinExchangedUntilNow
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferCoinExchangedUntilNow
     */
    amount?: string;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface ReserveFeeForPaysFeeInHalfOfferCoin
 */
export interface ReserveFeeForPaysFeeInHalfOfferCoin {
    /**
     * 
     * @type {string}
     * @memberof ReserveFeeForPaysFeeInHalfOfferCoin
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof ReserveFeeForPaysFeeInHalfOfferCoin
     */
    amount?: string;
}
/**
 * DepositMsgState defines the state of deposit message that contains state information as it is processed in the next batch or batches.
 * @export
 * @interface TendermintLiquidityV1beta1DepositMsgState
 */
export interface TendermintLiquidityV1beta1DepositMsgState {
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1DepositMsgState
     */
    msg_height?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1DepositMsgState
     */
    msg_index?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TendermintLiquidityV1beta1DepositMsgState
     */
    executed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TendermintLiquidityV1beta1DepositMsgState
     */
    succeeded?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TendermintLiquidityV1beta1DepositMsgState
     */
    to_be_deleted?: boolean;
    /**
     * 
     * @type {MsgDepositWithinBatch}
     * @memberof TendermintLiquidityV1beta1DepositMsgState
     */
    msg?: MsgDepositWithinBatch;
}
/**
 * `MsgDepositWithinBatch defines` an `sdk.Msg` type that supports submitting  a deposit request to the batch of the liquidity pool. Deposit is submitted to the batch of the Liquidity pool with the specified  `pool_id`, `deposit_coins` for reserve. This request is stacked in the batch of the liquidity pool, is not processed  immediately, and is processed in the `endblock` at the same time as other requests.  See: https://github.com/tendermint/liquidity/blob/develop/x/liquidity/spec/04_messages.md
 * @export
 * @interface TendermintLiquidityV1beta1MsgDepositWithinBatch
 */
export interface TendermintLiquidityV1beta1MsgDepositWithinBatch {
    /**
     * account address of the origin of this message
     * @type {string}
     * @memberof TendermintLiquidityV1beta1MsgDepositWithinBatch
     */
    depositor_address?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1MsgDepositWithinBatch
     */
    pool_id?: string;
    /**
     * 
     * @type {Array<InlineResponse200ParamsPoolCreationFee>}
     * @memberof TendermintLiquidityV1beta1MsgDepositWithinBatch
     */
    deposit_coins?: Array<InlineResponse200ParamsPoolCreationFee>;
}
/**
 * `MsgSwapWithinBatch` defines an sdk.Msg type that supports submitting a swap offer request to the batch of the liquidity pool. Submit swap offer to the liquidity pool batch with the specified the `pool_id`, `swap_type_id`, `demand_coin_denom` with the coin and the price you\'re offering and `offer_coin_fee` must be half of offer coin amount * current `params.swap_fee_rate` and ceil for reservation to pay fees. This request is stacked in the batch of the liquidity pool, is not processed  immediately, and is processed in the `endblock` at the same time as other requests. You must request the same fields as the pool. Only the default `swap_type_id` 1 is supported.  See: https://github.com/tendermint/liquidity/tree/develop/doc https://github.com/tendermint/liquidity/blob/develop/x/liquidity/spec/04_messages.md
 * @export
 * @interface TendermintLiquidityV1beta1MsgSwapWithinBatch
 */
export interface TendermintLiquidityV1beta1MsgSwapWithinBatch {
    /**
     * account address of the origin of this message
     * @type {string}
     * @memberof TendermintLiquidityV1beta1MsgSwapWithinBatch
     */
    swap_requester_address?: string;
    /**
     * id of swap type, must match the value in the pool. Only `swap_type_id` 1 is supported.
     * @type {string}
     * @memberof TendermintLiquidityV1beta1MsgSwapWithinBatch
     */
    pool_id?: string;
    /**
     * id of swap type. Must match the value in the pool.
     * @type {number}
     * @memberof TendermintLiquidityV1beta1MsgSwapWithinBatch
     */
    swap_type_id?: number;
    /**
     * 
     * @type {MsgSwapWithinBatchOfferCoin}
     * @memberof TendermintLiquidityV1beta1MsgSwapWithinBatch
     */
    offer_coin?: MsgSwapWithinBatchOfferCoin;
    /**
     * denom of demand coin to be exchanged on the swap request, must match the denom in the pool.
     * @type {string}
     * @memberof TendermintLiquidityV1beta1MsgSwapWithinBatch
     */
    demand_coin_denom?: string;
    /**
     * 
     * @type {MsgSwapWithinBatchOfferCoinFee}
     * @memberof TendermintLiquidityV1beta1MsgSwapWithinBatch
     */
    offer_coin_fee?: MsgSwapWithinBatchOfferCoinFee;
    /**
     * limit order price for the order, the price is the exchange ratio of X/Y where X is the amount of the first coin and Y is the amount  of the second coin when their denoms are sorted alphabetically.
     * @type {string}
     * @memberof TendermintLiquidityV1beta1MsgSwapWithinBatch
     */
    order_price?: string;
}
/**
 * `MsgWithdrawWithinBatch` defines an `sdk.Msg` type that supports submitting  a withdraw request to the batch of the liquidity pool. Withdraw is submitted to the batch from the Liquidity pool with the  specified `pool_id`, `pool_coin` of the pool. This request is stacked in the batch of the liquidity pool, is not processed  immediately, and is processed in the `endblock` at the same time as other requests.  See: https://github.com/tendermint/liquidity/blob/develop/x/liquidity/spec/04_messages.md
 * @export
 * @interface TendermintLiquidityV1beta1MsgWithdrawWithinBatch
 */
export interface TendermintLiquidityV1beta1MsgWithdrawWithinBatch {
    /**
     * account address of the origin of this message
     * @type {string}
     * @memberof TendermintLiquidityV1beta1MsgWithdrawWithinBatch
     */
    withdrawer_address?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1MsgWithdrawWithinBatch
     */
    pool_id?: string;
    /**
     * 
     * @type {MsgWithdrawWithinBatchPoolCoin}
     * @memberof TendermintLiquidityV1beta1MsgWithdrawWithinBatch
     */
    pool_coin?: MsgWithdrawWithinBatchPoolCoin;
}
/**
 * Params defines the parameters for the liquidity module.
 * @export
 * @interface TendermintLiquidityV1beta1Params
 */
export interface TendermintLiquidityV1beta1Params {
    /**
     * 
     * @type {Array<InlineResponse200ParamsPoolTypes>}
     * @memberof TendermintLiquidityV1beta1Params
     */
    pool_types?: Array<InlineResponse200ParamsPoolTypes>;
    /**
     * Minimum number of coins to be deposited to the liquidity pool on pool creation.
     * @type {string}
     * @memberof TendermintLiquidityV1beta1Params
     */
    min_init_deposit_amount?: string;
    /**
     * Initial mint amount of pool coins upon pool creation.
     * @type {string}
     * @memberof TendermintLiquidityV1beta1Params
     */
    init_pool_coin_mint_amount?: string;
    /**
     * Limit the size of each liquidity pool to minimize risk. In development, set to 0 for no limit. In production, set a limit.
     * @type {string}
     * @memberof TendermintLiquidityV1beta1Params
     */
    max_reserve_coin_amount?: string;
    /**
     * Fee paid to create a Liquidity Pool. Set a fee to prevent spamming.
     * @type {Array<InlineResponse200ParamsPoolCreationFee>}
     * @memberof TendermintLiquidityV1beta1Params
     */
    pool_creation_fee?: Array<InlineResponse200ParamsPoolCreationFee>;
    /**
     * Swap fee rate for every executed swap.
     * @type {string}
     * @memberof TendermintLiquidityV1beta1Params
     */
    swap_fee_rate?: string;
    /**
     * Reserve coin withdrawal with less proportion by withdrawFeeRate.
     * @type {string}
     * @memberof TendermintLiquidityV1beta1Params
     */
    withdraw_fee_rate?: string;
    /**
     * Maximum ratio of reserve coins that can be ordered at a swap order.
     * @type {string}
     * @memberof TendermintLiquidityV1beta1Params
     */
    max_order_amount_ratio?: string;
    /**
     * The smallest unit batch height for every liquidity pool.
     * @type {number}
     * @memberof TendermintLiquidityV1beta1Params
     */
    unit_batch_height?: number;
    /**
     * Circuit breaker enables or disables transaction messages in liquidity module.
     * @type {boolean}
     * @memberof TendermintLiquidityV1beta1Params
     */
    circuit_breaker_enabled?: boolean;
}
/**
 * Pool defines the liquidity pool that contains pool information.
 * @export
 * @interface TendermintLiquidityV1beta1Pool
 */
export interface TendermintLiquidityV1beta1Pool {
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1Pool
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof TendermintLiquidityV1beta1Pool
     */
    type_id?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TendermintLiquidityV1beta1Pool
     */
    reserve_coin_denoms?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1Pool
     */
    reserve_account_address?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1Pool
     */
    pool_coin_denom?: string;
}
/**
 * PoolBatch defines the batch or batches of a given liquidity pool that contains indexes of deposit, withdraw, and swap messages.  Index param increments by 1 if the pool id is same.
 * @export
 * @interface TendermintLiquidityV1beta1PoolBatch
 */
export interface TendermintLiquidityV1beta1PoolBatch {
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1PoolBatch
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1PoolBatch
     */
    index?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1PoolBatch
     */
    begin_height?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1PoolBatch
     */
    deposit_msg_index?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1PoolBatch
     */
    withdraw_msg_index?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1PoolBatch
     */
    swap_msg_index?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TendermintLiquidityV1beta1PoolBatch
     */
    executed?: boolean;
}
/**
 * Structure for the pool type to distinguish the characteristics of the reserve pools.
 * @export
 * @interface TendermintLiquidityV1beta1PoolType
 */
export interface TendermintLiquidityV1beta1PoolType {
    /**
     * 
     * @type {number}
     * @memberof TendermintLiquidityV1beta1PoolType
     */
    id?: number;
    /**
     * name of the pool type.
     * @type {string}
     * @memberof TendermintLiquidityV1beta1PoolType
     */
    name?: string;
    /**
     * minimum number of reserveCoins for LiquidityPoolType, only 2 reserve coins are supported.
     * @type {number}
     * @memberof TendermintLiquidityV1beta1PoolType
     */
    min_reserve_coin_num?: number;
    /**
     * maximum number of reserveCoins for LiquidityPoolType, only 2 reserve coins are supported.
     * @type {number}
     * @memberof TendermintLiquidityV1beta1PoolType
     */
    max_reserve_coin_num?: number;
    /**
     * description of the pool type.
     * @type {string}
     * @memberof TendermintLiquidityV1beta1PoolType
     */
    description?: string;
}
/**
 * the response type for the QueryLiquidityPoolBatchResponse RPC method. Returns the liquidity pool batch that corresponds to the requested pool_id.
 * @export
 * @interface TendermintLiquidityV1beta1QueryLiquidityPoolBatchResponse
 */
export interface TendermintLiquidityV1beta1QueryLiquidityPoolBatchResponse {
    /**
     * 
     * @type {InlineResponse2003Batch}
     * @memberof TendermintLiquidityV1beta1QueryLiquidityPoolBatchResponse
     */
    batch?: InlineResponse2003Batch;
}
/**
 * the response type for the QueryLiquidityPoolResponse RPC method. Returns the liquidity pool that corresponds to the requested pool_id.
 * @export
 * @interface TendermintLiquidityV1beta1QueryLiquidityPoolResponse
 */
export interface TendermintLiquidityV1beta1QueryLiquidityPoolResponse {
    /**
     * 
     * @type {InlineResponse2001Pools}
     * @memberof TendermintLiquidityV1beta1QueryLiquidityPoolResponse
     */
    pool?: InlineResponse2001Pools;
}
/**
 * the response type for the QueryLiquidityPoolsResponse RPC method. This includes a list of all existing liquidity pools and paging results that contain next_key and total count.
 * @export
 * @interface TendermintLiquidityV1beta1QueryLiquidityPoolsResponse
 */
export interface TendermintLiquidityV1beta1QueryLiquidityPoolsResponse {
    /**
     * 
     * @type {Array<InlineResponse2001Pools>}
     * @memberof TendermintLiquidityV1beta1QueryLiquidityPoolsResponse
     */
    pools?: Array<InlineResponse2001Pools>;
    /**
     * 
     * @type {InlineResponse2001Pagination}
     * @memberof TendermintLiquidityV1beta1QueryLiquidityPoolsResponse
     */
    pagination?: InlineResponse2001Pagination;
}
/**
 * the response type for the QueryParamsResponse RPC method. This includes current parameter of the liquidity module.
 * @export
 * @interface TendermintLiquidityV1beta1QueryParamsResponse
 */
export interface TendermintLiquidityV1beta1QueryParamsResponse {
    /**
     * 
     * @type {InlineResponse200Params}
     * @memberof TendermintLiquidityV1beta1QueryParamsResponse
     */
    params?: InlineResponse200Params;
}
/**
 * the response type for the QueryPoolBatchDepositMsg RPC method. This includes a batch swap message of the batch.
 * @export
 * @interface TendermintLiquidityV1beta1QueryPoolBatchDepositMsgResponse
 */
export interface TendermintLiquidityV1beta1QueryPoolBatchDepositMsgResponse {
    /**
     * 
     * @type {InlineResponse2004Deposits}
     * @memberof TendermintLiquidityV1beta1QueryPoolBatchDepositMsgResponse
     */
    deposit?: InlineResponse2004Deposits;
}
/**
 * the response type for the QueryPoolBatchDeposit RPC method. This includes a list of all currently existing deposit messages of the batch and paging results that contain next_key and total count.
 * @export
 * @interface TendermintLiquidityV1beta1QueryPoolBatchDepositMsgsResponse
 */
export interface TendermintLiquidityV1beta1QueryPoolBatchDepositMsgsResponse {
    /**
     * 
     * @type {Array<InlineResponse2004Deposits>}
     * @memberof TendermintLiquidityV1beta1QueryPoolBatchDepositMsgsResponse
     */
    deposits?: Array<InlineResponse2004Deposits>;
    /**
     * 
     * @type {InlineResponse2001Pagination}
     * @memberof TendermintLiquidityV1beta1QueryPoolBatchDepositMsgsResponse
     */
    pagination?: InlineResponse2001Pagination;
}
/**
 * the response type for the QueryPoolBatchSwapMsg RPC method. This includes a batch swap message of the batch.
 * @export
 * @interface TendermintLiquidityV1beta1QueryPoolBatchSwapMsgResponse
 */
export interface TendermintLiquidityV1beta1QueryPoolBatchSwapMsgResponse {
    /**
     * 
     * @type {InlineResponse2006Swaps}
     * @memberof TendermintLiquidityV1beta1QueryPoolBatchSwapMsgResponse
     */
    swap?: InlineResponse2006Swaps;
}
/**
 * the response type for the QueryPoolBatchSwapMsgs RPC method. This includes list of all currently existing swap messages of the batch and paging results that contain next_key and total count.
 * @export
 * @interface TendermintLiquidityV1beta1QueryPoolBatchSwapMsgsResponse
 */
export interface TendermintLiquidityV1beta1QueryPoolBatchSwapMsgsResponse {
    /**
     * 
     * @type {Array<InlineResponse2006Swaps>}
     * @memberof TendermintLiquidityV1beta1QueryPoolBatchSwapMsgsResponse
     */
    swaps?: Array<InlineResponse2006Swaps>;
    /**
     * 
     * @type {InlineResponse2001Pagination}
     * @memberof TendermintLiquidityV1beta1QueryPoolBatchSwapMsgsResponse
     */
    pagination?: InlineResponse2001Pagination;
}
/**
 * the response type for the QueryPoolBatchWithdrawMsg RPC method. This includes a batch swap message of the batch.
 * @export
 * @interface TendermintLiquidityV1beta1QueryPoolBatchWithdrawMsgResponse
 */
export interface TendermintLiquidityV1beta1QueryPoolBatchWithdrawMsgResponse {
    /**
     * 
     * @type {InlineResponse2008Withdraws}
     * @memberof TendermintLiquidityV1beta1QueryPoolBatchWithdrawMsgResponse
     */
    withdraw?: InlineResponse2008Withdraws;
}
/**
 * the response type for the QueryPoolBatchWithdraw RPC method. This includes a list of all currently existing withdraw messages of the batch and paging results that contain next_key and total count.
 * @export
 * @interface TendermintLiquidityV1beta1QueryPoolBatchWithdrawMsgsResponse
 */
export interface TendermintLiquidityV1beta1QueryPoolBatchWithdrawMsgsResponse {
    /**
     * 
     * @type {Array<InlineResponse2008Withdraws>}
     * @memberof TendermintLiquidityV1beta1QueryPoolBatchWithdrawMsgsResponse
     */
    withdraws?: Array<InlineResponse2008Withdraws>;
    /**
     * 
     * @type {InlineResponse2008Pagination}
     * @memberof TendermintLiquidityV1beta1QueryPoolBatchWithdrawMsgsResponse
     */
    pagination?: InlineResponse2008Pagination;
}
/**
 * SwapMsgState defines the state of the swap message that contains state information as the message is processed in the next batch or batches.
 * @export
 * @interface TendermintLiquidityV1beta1SwapMsgState
 */
export interface TendermintLiquidityV1beta1SwapMsgState {
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1SwapMsgState
     */
    msg_height?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1SwapMsgState
     */
    msg_index?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TendermintLiquidityV1beta1SwapMsgState
     */
    executed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TendermintLiquidityV1beta1SwapMsgState
     */
    succeeded?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TendermintLiquidityV1beta1SwapMsgState
     */
    to_be_deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1SwapMsgState
     */
    order_expiry_height?: string;
    /**
     * 
     * @type {OfferCoinExchangedUntilNow}
     * @memberof TendermintLiquidityV1beta1SwapMsgState
     */
    exchanged_offer_coin?: OfferCoinExchangedUntilNow;
    /**
     * 
     * @type {OfferCoinCurrentlyRemainingToBeExchanged}
     * @memberof TendermintLiquidityV1beta1SwapMsgState
     */
    remaining_offer_coin?: OfferCoinCurrentlyRemainingToBeExchanged;
    /**
     * 
     * @type {ReserveFeeForPaysFeeInHalfOfferCoin}
     * @memberof TendermintLiquidityV1beta1SwapMsgState
     */
    reserved_offer_coin_fee?: ReserveFeeForPaysFeeInHalfOfferCoin;
    /**
     * 
     * @type {MsgSwapWithinBatch}
     * @memberof TendermintLiquidityV1beta1SwapMsgState
     */
    msg?: MsgSwapWithinBatch;
}
/**
 * WithdrawMsgState defines the state of the withdraw message that contains state information as the message is processed in the next batch or batches.
 * @export
 * @interface TendermintLiquidityV1beta1WithdrawMsgState
 */
export interface TendermintLiquidityV1beta1WithdrawMsgState {
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1WithdrawMsgState
     */
    msg_height?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintLiquidityV1beta1WithdrawMsgState
     */
    msg_index?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TendermintLiquidityV1beta1WithdrawMsgState
     */
    executed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TendermintLiquidityV1beta1WithdrawMsgState
     */
    succeeded?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TendermintLiquidityV1beta1WithdrawMsgState
     */
    to_be_deleted?: boolean;
    /**
     * 
     * @type {MsgWithdrawWithinBatch}
     * @memberof TendermintLiquidityV1beta1WithdrawMsgState
     */
    msg?: MsgWithdrawWithinBatch;
}

/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the liquidity pool that corresponds to the pool_id.
         * @summary Get specific liquidity pool.
         * @param {string} poolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityPool: async (poolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            if (poolId === null || poolId === undefined) {
                throw new RequiredError('poolId','Required parameter poolId was null or undefined when calling liquidityPool.');
            }
            const localVarPath = `/cosmos/liquidity/v1beta1/pools/{pool_id}`
                .replace(`{${"pool_id"}}`, encodeURIComponent(String(poolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current batch of the pool that corresponds to the pool_id.
         * @summary Get the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityPoolBatch: async (poolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            if (poolId === null || poolId === undefined) {
                throw new RequiredError('poolId','Required parameter poolId was null or undefined when calling liquidityPoolBatch.');
            }
            const localVarPath = `/cosmos/liquidity/v1beta1/pools/{pool_id}/batch`
                .replace(`{${"pool_id"}}`, encodeURIComponent(String(poolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns the liquidity pool corresponding to the pool_coin_denom.
         * @summary Get specific liquidity pool corresponding to the pool_coin_denom.
         * @param {string} poolCoinDenom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityPoolByPoolCoinDenom: async (poolCoinDenom: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolCoinDenom' is not null or undefined
            if (poolCoinDenom === null || poolCoinDenom === undefined) {
                throw new RequiredError('poolCoinDenom','Required parameter poolCoinDenom was null or undefined when calling liquidityPoolByPoolCoinDenom.');
            }
            const localVarPath = `/cosmos/liquidity/v1beta1/pools/pool_coin_denom/{pool_coin_denom}`
                .replace(`{${"pool_coin_denom"}}`, encodeURIComponent(String(poolCoinDenom)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns the liquidity pool corresponding to the reserve account.
         * @summary Get specific liquidity pool corresponding to the reserve account.
         * @param {string} reserveAcc 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityPoolByReserveAcc: async (reserveAcc: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'reserveAcc' is not null or undefined
            if (reserveAcc === null || reserveAcc === undefined) {
                throw new RequiredError('reserveAcc','Required parameter reserveAcc was null or undefined when calling liquidityPoolByReserveAcc.');
            }
            const localVarPath = `/cosmos/liquidity/v1beta1/pools/reserve_acc/{reserve_acc}`
                .replace(`{${"reserve_acc"}}`, encodeURIComponent(String(reserveAcc)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all liquidity pools with pagination result.
         * @summary Get existing liquidity pools.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityPools: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/liquidity/v1beta1/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all parameters of the liquidity module.
         * @summary Get all parameters of the liquidity module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityQueries: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/liquidity/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the deposit message that corresponds to the msg_index in the pool\'s current batch.
         * @summary Get a specific deposit message in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} msgIndex target msg_index of the pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolBatchDepositMsg: async (poolId: string, msgIndex: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            if (poolId === null || poolId === undefined) {
                throw new RequiredError('poolId','Required parameter poolId was null or undefined when calling poolBatchDepositMsg.');
            }
            // verify required parameter 'msgIndex' is not null or undefined
            if (msgIndex === null || msgIndex === undefined) {
                throw new RequiredError('msgIndex','Required parameter msgIndex was null or undefined when calling poolBatchDepositMsg.');
            }
            const localVarPath = `/cosmos/liquidity/v1beta1/pools/{pool_id}/batch/deposits/{msg_index}`
                .replace(`{${"pool_id"}}`, encodeURIComponent(String(poolId)))
                .replace(`{${"msg_index"}}`, encodeURIComponent(String(msgIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all deposit messages in the current batch of the pool with pagination result.
         * @summary Get all deposit messages in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolBatchDepositMsgs: async (poolId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            if (poolId === null || poolId === undefined) {
                throw new RequiredError('poolId','Required parameter poolId was null or undefined when calling poolBatchDepositMsgs.');
            }
            const localVarPath = `/cosmos/liquidity/v1beta1/pools/{pool_id}/batch/deposits`
                .replace(`{${"pool_id"}}`, encodeURIComponent(String(poolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the swap message that corresponds to the msg_index in the pool\'s current batch
         * @summary Get a specific swap message in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} msgIndex target msg_index of the pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolBatchSwapMsg: async (poolId: string, msgIndex: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            if (poolId === null || poolId === undefined) {
                throw new RequiredError('poolId','Required parameter poolId was null or undefined when calling poolBatchSwapMsg.');
            }
            // verify required parameter 'msgIndex' is not null or undefined
            if (msgIndex === null || msgIndex === undefined) {
                throw new RequiredError('msgIndex','Required parameter msgIndex was null or undefined when calling poolBatchSwapMsg.');
            }
            const localVarPath = `/cosmos/liquidity/v1beta1/pools/{pool_id}/batch/swaps/{msg_index}`
                .replace(`{${"pool_id"}}`, encodeURIComponent(String(poolId)))
                .replace(`{${"msg_index"}}`, encodeURIComponent(String(msgIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all swap messages in the current batch of the pool with pagination result.
         * @summary Get all swap messages in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolBatchSwapMsgs: async (poolId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            if (poolId === null || poolId === undefined) {
                throw new RequiredError('poolId','Required parameter poolId was null or undefined when calling poolBatchSwapMsgs.');
            }
            const localVarPath = `/cosmos/liquidity/v1beta1/pools/{pool_id}/batch/swaps`
                .replace(`{${"pool_id"}}`, encodeURIComponent(String(poolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the withdraw message that corresponds to the msg_index in the pool\'s current batch.
         * @summary Get a specific withdraw message in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} msgIndex target msg_index of the pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolBatchWithdrawMsg: async (poolId: string, msgIndex: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            if (poolId === null || poolId === undefined) {
                throw new RequiredError('poolId','Required parameter poolId was null or undefined when calling poolBatchWithdrawMsg.');
            }
            // verify required parameter 'msgIndex' is not null or undefined
            if (msgIndex === null || msgIndex === undefined) {
                throw new RequiredError('msgIndex','Required parameter msgIndex was null or undefined when calling poolBatchWithdrawMsg.');
            }
            const localVarPath = `/cosmos/liquidity/v1beta1/pools/{pool_id}/batch/withdraws/{msg_index}`
                .replace(`{${"pool_id"}}`, encodeURIComponent(String(poolId)))
                .replace(`{${"msg_index"}}`, encodeURIComponent(String(msgIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all withdraw messages in the current batch of the pool with pagination result.
         * @summary Get all withdraw messages in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolBatchWithdrawMsgs: async (poolId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            if (poolId === null || poolId === undefined) {
                throw new RequiredError('poolId','Required parameter poolId was null or undefined when calling poolBatchWithdrawMsgs.');
            }
            const localVarPath = `/cosmos/liquidity/v1beta1/pools/{pool_id}/batch/withdraws`
                .replace(`{${"pool_id"}}`, encodeURIComponent(String(poolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the liquidity pool that corresponds to the pool_id.
         * @summary Get specific liquidity pool.
         * @param {string} poolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liquidityPool(poolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).liquidityPool(poolId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the current batch of the pool that corresponds to the pool_id.
         * @summary Get the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liquidityPoolBatch(poolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).liquidityPoolBatch(poolId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * It returns the liquidity pool corresponding to the pool_coin_denom.
         * @summary Get specific liquidity pool corresponding to the pool_coin_denom.
         * @param {string} poolCoinDenom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liquidityPoolByPoolCoinDenom(poolCoinDenom: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).liquidityPoolByPoolCoinDenom(poolCoinDenom, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * It returns the liquidity pool corresponding to the reserve account.
         * @summary Get specific liquidity pool corresponding to the reserve account.
         * @param {string} reserveAcc 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liquidityPoolByReserveAcc(reserveAcc: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).liquidityPoolByReserveAcc(reserveAcc, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of all liquidity pools with pagination result.
         * @summary Get existing liquidity pools.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liquidityPools(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).liquidityPools(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns all parameters of the liquidity module.
         * @summary Get all parameters of the liquidity module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liquidityQueries(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).liquidityQueries(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the deposit message that corresponds to the msg_index in the pool\'s current batch.
         * @summary Get a specific deposit message in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} msgIndex target msg_index of the pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async poolBatchDepositMsg(poolId: string, msgIndex: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).poolBatchDepositMsg(poolId, msgIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of all deposit messages in the current batch of the pool with pagination result.
         * @summary Get all deposit messages in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async poolBatchDepositMsgs(poolId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).poolBatchDepositMsgs(poolId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the swap message that corresponds to the msg_index in the pool\'s current batch
         * @summary Get a specific swap message in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} msgIndex target msg_index of the pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async poolBatchSwapMsg(poolId: string, msgIndex: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).poolBatchSwapMsg(poolId, msgIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of all swap messages in the current batch of the pool with pagination result.
         * @summary Get all swap messages in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async poolBatchSwapMsgs(poolId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).poolBatchSwapMsgs(poolId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the withdraw message that corresponds to the msg_index in the pool\'s current batch.
         * @summary Get a specific withdraw message in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} msgIndex target msg_index of the pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async poolBatchWithdrawMsg(poolId: string, msgIndex: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).poolBatchWithdrawMsg(poolId, msgIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of all withdraw messages in the current batch of the pool with pagination result.
         * @summary Get all withdraw messages in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async poolBatchWithdrawMsgs(poolId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).poolBatchWithdrawMsgs(poolId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the liquidity pool that corresponds to the pool_id.
         * @summary Get specific liquidity pool.
         * @param {string} poolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityPool(poolId: string, options?: any): AxiosPromise<InlineResponse2002> {
            return QueryApiFp(configuration).liquidityPool(poolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current batch of the pool that corresponds to the pool_id.
         * @summary Get the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityPoolBatch(poolId: string, options?: any): AxiosPromise<InlineResponse2003> {
            return QueryApiFp(configuration).liquidityPoolBatch(poolId, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns the liquidity pool corresponding to the pool_coin_denom.
         * @summary Get specific liquidity pool corresponding to the pool_coin_denom.
         * @param {string} poolCoinDenom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityPoolByPoolCoinDenom(poolCoinDenom: string, options?: any): AxiosPromise<InlineResponse2002> {
            return QueryApiFp(configuration).liquidityPoolByPoolCoinDenom(poolCoinDenom, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns the liquidity pool corresponding to the reserve account.
         * @summary Get specific liquidity pool corresponding to the reserve account.
         * @param {string} reserveAcc 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityPoolByReserveAcc(reserveAcc: string, options?: any): AxiosPromise<InlineResponse2002> {
            return QueryApiFp(configuration).liquidityPoolByReserveAcc(reserveAcc, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all liquidity pools with pagination result.
         * @summary Get existing liquidity pools.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityPools(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse2001> {
            return QueryApiFp(configuration).liquidityPools(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all parameters of the liquidity module.
         * @summary Get all parameters of the liquidity module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityQueries(options?: any): AxiosPromise<InlineResponse200> {
            return QueryApiFp(configuration).liquidityQueries(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the deposit message that corresponds to the msg_index in the pool\'s current batch.
         * @summary Get a specific deposit message in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} msgIndex target msg_index of the pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolBatchDepositMsg(poolId: string, msgIndex: string, options?: any): AxiosPromise<InlineResponse2005> {
            return QueryApiFp(configuration).poolBatchDepositMsg(poolId, msgIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all deposit messages in the current batch of the pool with pagination result.
         * @summary Get all deposit messages in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolBatchDepositMsgs(poolId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse2004> {
            return QueryApiFp(configuration).poolBatchDepositMsgs(poolId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the swap message that corresponds to the msg_index in the pool\'s current batch
         * @summary Get a specific swap message in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} msgIndex target msg_index of the pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolBatchSwapMsg(poolId: string, msgIndex: string, options?: any): AxiosPromise<InlineResponse2007> {
            return QueryApiFp(configuration).poolBatchSwapMsg(poolId, msgIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all swap messages in the current batch of the pool with pagination result.
         * @summary Get all swap messages in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolBatchSwapMsgs(poolId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse2006> {
            return QueryApiFp(configuration).poolBatchSwapMsgs(poolId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the withdraw message that corresponds to the msg_index in the pool\'s current batch.
         * @summary Get a specific withdraw message in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} msgIndex target msg_index of the pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolBatchWithdrawMsg(poolId: string, msgIndex: string, options?: any): AxiosPromise<InlineResponse2009> {
            return QueryApiFp(configuration).poolBatchWithdrawMsg(poolId, msgIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all withdraw messages in the current batch of the pool with pagination result.
         * @summary Get all withdraw messages in the pool\'s current batch.
         * @param {string} poolId id of the target pool for query
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolBatchWithdrawMsgs(poolId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse2008> {
            return QueryApiFp(configuration).poolBatchWithdrawMsgs(poolId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * Returns the liquidity pool that corresponds to the pool_id.
     * @summary Get specific liquidity pool.
     * @param {string} poolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public liquidityPool(poolId: string, options?: any) {
        return QueryApiFp(this.configuration).liquidityPool(poolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current batch of the pool that corresponds to the pool_id.
     * @summary Get the pool\'s current batch.
     * @param {string} poolId id of the target pool for query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public liquidityPoolBatch(poolId: string, options?: any) {
        return QueryApiFp(this.configuration).liquidityPoolBatch(poolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns the liquidity pool corresponding to the pool_coin_denom.
     * @summary Get specific liquidity pool corresponding to the pool_coin_denom.
     * @param {string} poolCoinDenom 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public liquidityPoolByPoolCoinDenom(poolCoinDenom: string, options?: any) {
        return QueryApiFp(this.configuration).liquidityPoolByPoolCoinDenom(poolCoinDenom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns the liquidity pool corresponding to the reserve account.
     * @summary Get specific liquidity pool corresponding to the reserve account.
     * @param {string} reserveAcc 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public liquidityPoolByReserveAcc(reserveAcc: string, options?: any) {
        return QueryApiFp(this.configuration).liquidityPoolByReserveAcc(reserveAcc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all liquidity pools with pagination result.
     * @summary Get existing liquidity pools.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public liquidityPools(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).liquidityPools(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all parameters of the liquidity module.
     * @summary Get all parameters of the liquidity module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public liquidityQueries(options?: any) {
        return QueryApiFp(this.configuration).liquidityQueries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the deposit message that corresponds to the msg_index in the pool\'s current batch.
     * @summary Get a specific deposit message in the pool\'s current batch.
     * @param {string} poolId id of the target pool for query
     * @param {string} msgIndex target msg_index of the pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public poolBatchDepositMsg(poolId: string, msgIndex: string, options?: any) {
        return QueryApiFp(this.configuration).poolBatchDepositMsg(poolId, msgIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all deposit messages in the current batch of the pool with pagination result.
     * @summary Get all deposit messages in the pool\'s current batch.
     * @param {string} poolId id of the target pool for query
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public poolBatchDepositMsgs(poolId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).poolBatchDepositMsgs(poolId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the swap message that corresponds to the msg_index in the pool\'s current batch
     * @summary Get a specific swap message in the pool\'s current batch.
     * @param {string} poolId id of the target pool for query
     * @param {string} msgIndex target msg_index of the pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public poolBatchSwapMsg(poolId: string, msgIndex: string, options?: any) {
        return QueryApiFp(this.configuration).poolBatchSwapMsg(poolId, msgIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all swap messages in the current batch of the pool with pagination result.
     * @summary Get all swap messages in the pool\'s current batch.
     * @param {string} poolId id of the target pool for query
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public poolBatchSwapMsgs(poolId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).poolBatchSwapMsgs(poolId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the withdraw message that corresponds to the msg_index in the pool\'s current batch.
     * @summary Get a specific withdraw message in the pool\'s current batch.
     * @param {string} poolId id of the target pool for query
     * @param {string} msgIndex target msg_index of the pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public poolBatchWithdrawMsg(poolId: string, msgIndex: string, options?: any) {
        return QueryApiFp(this.configuration).poolBatchWithdrawMsg(poolId, msgIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all withdraw messages in the current batch of the pool with pagination result.
     * @summary Get all withdraw messages in the pool\'s current batch.
     * @param {string} poolId id of the target pool for query
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public poolBatchWithdrawMsgs(poolId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).poolBatchWithdrawMsgs(poolId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }
}


